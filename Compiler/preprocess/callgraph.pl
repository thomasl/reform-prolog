%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%			     CALL GRAPHS
%
%   Debray's algorithm requires the callers of a predicate where success
% patterns change to be recomputed. Here is where the call graph is
% constructed, by a dictionary of "predicate -> callers" entries.
%

:- ensure_loaded('../util/dict').
:- ensure_loaded('load-rp-file').


%% This predicate constructs the callers relation as a separate dictionary.
%
construct_cg_of_ixstructs(ClauseDB,Callables,CG) :-
	list_dict(ClauseDB,List),
	empty_dict(InitCG),
	construct_cg_list_of_ixstructs(List,Callables,InitCG,CG).

lookup_cg(Pred,CG,Callers) :-
	lookup(Pred,CG,Callers).

%%%
%%  Each entry is an item (P/N,info(CompileMode,IxStruct,Directives,File))
% where an IxStruct is either ix(V,C,L,N,S,Cls) or
% rp(Base,ParRecCls,OrigRecCls,RecType,LeftBody,RightBody)
%
construct_cg_list_of_ixstructs([],_Callables,CG,CG).

construct_cg_list_of_ixstructs(
	[(_PN,info(_CompileMode,ix(_V,_C,_L,_N,_S,Cstr),_Ds,_F))|Es],Callables,CG0,CG2) :- !,
	Cstr =.. [_|Cs],
	callers(Cs,Callables,CG0,CG1),
	construct_cg_list_of_ixstructs(Es,Callables,CG1,CG2).

construct_cg_list_of_ixstructs(
	[(_PN,info(_CompileMode,rp(_Base,Rec,_Orig,_Type,LB_ce,RB_ce),_Ds,_F))|Es],Callables,CG0,CG3) :- !,
	Rec = ((H :- rec(_LP,LB,_R,RB,_RP)),_E),
	construct_call_approx(LB,RB,H,AppxCls),
	callers([AppxCls],Callables,CG0,CG1), % par pred calls l/r bodies
	LB_ce = (LB_clause,_),
	RB_ce = (RB_clause,_),
	Cs = [LB_clause,RB_clause],
	callers(Cs,Callables,CG1,CG2),             % bodies call sub-preds
	construct_cg_list_of_ixstructs(Es,Callables,CG2,CG3).

%%%
%%  Construct a pseudo clause for purposes of call graph.
% Idea: throw away 'none' bodies (the body did not exist)
%
construct_call_approx(none,RB,H,Appx) :- !,
	( RB = none ->
	  Appx = (H :- true)
	; Appx = (H :- RB)
	).
construct_call_approx(LB,RB,H,Appx) :-
	( RB = none ->
	  Appx = (H :- LB)
	; Appx = (H :- LB,RB)
	).


%% Collect all predicates calling a given predicate.
%
callers([],_Callables,CG,CG).

callers([C|Cs],Callables,CG0,CG2) :-
	( C = (H :- B) ->
	  functor(H,P,N),
	  callers_clause(B,Callables,P/N,CG0,CG1)
	; C = ((H :- B),_Env) ->
	  functor(H,P,N),
	  callers_clause(B,Callables,P/N,CG0,CG1)
	; C = no_clause -> % when there actually was no body
	  CG0 = CG1
	; C = dummy -> % appears when a pseudo-pred is generated by rp-fload2
	  CG0 = CG1
	; CG0 = CG1,
	  sys_warning('callers/3: strange item ~q',[C])
	),
	callers(Cs,Callables,CG1,CG2).

%%%
%%  For rp-preds, we say that the main rp-pred calls the preds in the bodies,
% even though there is an intervening pseudo-predicate 'foo_N_left(right)_body'.
%
rp_callers(    [],_PN, CG,  CG).

rp_callers([C|Cs], PN, CG0, CG2) :-
	( C = (_H :- B) ->
	    callers_clause(B,PN,CG0,CG1)
	; C = ((_H :- B),_Env) ->
	    callers_clause(B,PN,CG0,CG1)
	; CG0 = CG1,
	    sys_warning('rp_callers/3: strange item ~q',[C])
	),
	rp_callers(Cs,PN,CG1,CG2).

%

callers_clause((G,Gs),Callables,Caller,CG0,CG2) :- !,
	( primitive(G) ->
	    CG0 = CG1
	; meta_primitive(G) ->
	    ( explicit_meta_call(G,P,N) ->
	        add_caller(P/N,Caller,CG0,CG1)
	    ; true,
	        var_caller(Callables,Caller,CG0,CG1)
	    )
	; true,
	    functor(G,P,N),
	    add_caller(P/N,Caller,CG0,CG1)
	),
	callers_clause(Gs,Callables,Caller,CG1,CG2).

callers_clause(G,Callables,Caller,CG0,CG1) :-
	( primitive(G) ->
	    CG0 = CG1
	; meta_primitive(G) ->
	    ( explicit_meta_call(G,P,N) ->
	        add_caller(P/N,Caller,CG0,CG1)
	    ; true,
	        var_caller(Callables,Caller,CG0,CG1)
	    )
	; true,
	    functor(G,P,N),
	    add_caller(P/N,Caller,CG0,CG1)
	).

%

add_caller(PN,Caller,CG0,CG1) :-
	( lookup(PN,CG0,Callers) ->
	  true
	; Callers = []
	),
	update(PN,[Caller|Callers],CG0,CG1).


remove_caller(PN,Caller,CG0,CG1) :-
	( lookup(PN,CG0,Callers) ->
	  true
	; Callers = []
	),
	select_first_caller(Callers,Caller,NewCallers),
	update(PN,NewCallers,CG0,CG1).


var_caller([],_Caller,CG,CG).

var_caller([predicate(PN,Directives)|Ps],Caller,CG0,CG2) :-
	( has_directive(parallel,Directives) ->
	    ( has_directive(callable,Directives) ->
	        add_caller(PN,Caller,CG0,CG1)
	    ; true,
	        CG1 = CG0
	    )
	; true,
	    add_caller(PN,Caller,CG0,CG1)
	),
	var_caller(Ps,Caller,CG1,CG2).


% NB. If arg 2 is not found in arg 1, call graph is inconsistent.

select_first_caller([],X,[]) :- !,
	sys_error('select_first_caller/3: inconsistent call graph ~q',[X]).

select_first([X|Xs],X,Xs) :- !.

select_first([Y|Xs],X,[Y|Zs]) :- select_first(Xs,X,Zs).

