%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%		   INTRODUCTION OF LOCAL OPERATIONS
%
%   For NUMA architectures, we can convert some instructions into more
% specific ones that use locality information. The compiler already emits
% pragmas for this purpose; the following phase introduces locality instructions.
%
%
% NOTE: all the patterns below follow those generated by shared-unify.pl
%       precisely (or SHOULD DO THAT!).
%       This yields slightly inefficient code, but is preferrable to
%       hand-compiling the pattern matching.
%
locality_pho(Xs,Ys) :-
	loc_pho(Xs,Ys,[]).

loc_pho([]) --> [].
loc_pho([comment(pragma([Info1,Info2])),'Get_Value'(R1,R2)|Xs]) --> !,
	[comment(pragma([Info1,Info2]))],
	( { Info1 = info(R1,P1,S1,L1),
	    Info2 = info(R2,P2,S2,L2),
	    requires_lock(P1,S1,L1,P2,S2,L2) } ->
	  ['Global_Get_Value'(R1,R2)]
	; ['Get_Value'(R1,R2)]
	),
	loc_pho(Xs).
loc_pho([comment(pragma([Info1,Info2])),'Put_Value'(R0,R2),'Get_Value'(R1,R2)|Xs]) --> !,
	[comment(pragma([Info1,Info2])),'Put_Value'(R0,R2)],
	( { Info1 = info(R1,P1,S1,L1),
	    Info2 = info(R2,P2,S2,L2),
	    requires_lock(P1,S1,L1,P2,S2,L2) } ->
	  ['Global_Get_Value'(R1,R2)]
	; ['Get_Value'(R1,R2)]
	),
	loc_pho(Xs).
loc_pho([comment(pragma([Info])),'Get_Constant'(C,R)|Xs]) --> !,
	[comment(pragma([Info]))],
	( { Info = info(R,P,S,L),
	    requires_lock(P,S,L,gnd,gnd,local) } ->
	  ['Global_Get_Constant'(C,R)]
	; ['Get_Constant'(C,R)]
	),
	loc_pho(Xs).
loc_pho([comment(pragma([Info])),'Put_Value'(R0,R),'Get_Constant'(C,R)|Xs]) --> !,
	[comment(pragma([Info])),'Put_Value'(R0,R)],
	( { Info = info(R0,P,S,L),
	    requires_lock(P,S,L,gnd,gnd,local) } ->
	  ['Global_Get_Constant'(C,R)]
	; ['Get_Constant'(C,R)]
	),
	loc_pho(Xs).
loc_pho([comment(pragma([Info1,Info2])),'Unify_Value'(R)|Xs]) --> !,
	[comment(pragma([Info1,Info2]))],
	( { Info1 = info(R,P1,S1,L1),
	    Info2 = unified_with(P2,S2,L2),
	    requires_lock(P1,S1,L1,P2,S2,L2) } ->
	  ['Global_Unify_Value'(R)]
	; ['Unify_Value'(R)]
	),
	loc_pho(Xs).
loc_pho([comment(pragma([Info1,Info2])),'Unify_Local_Value'(R)|Xs]) --> !,
	[comment(pragma([Info1,Info2]))],
	( { Info1 = info(R,P1,S1,L1),
	    Info2 = unified_with(P2,S2,L2),
	    requires_lock(P1,S1,L1,P2,S2,L2) } ->
	  ['Global_Unify_Local_Value'(R)]
	; ['Unify_Local_Value'(R)]
	),
	loc_pho(Xs).
loc_pho([comment(pragma([Info])),'Unify_Constant'(C)|Xs]) --> !,
	[comment(pragma([Info]))],
	( { Info = unified_with(P,S,L),
	    requires_lock(P,S,L,gnd,gnd,local) } ->
	  ['Global_Unify_Constant'(C)]
	; ['Unify_Constant'(C)]
	),
	loc_pho(Xs).
loc_pho([X|Xs]) --> [X], loc_pho(Xs).


%%
%   We over estimate the need for locking bindings in order to be safe. Thus, if
% either item is non-local, or if either item is non-ground, then the instruction
% requires locking binding. We could do better in the case of constants, where nv
% (non-var) is sufficient.
%
requires_lock(P1,_S1, L1, P2,_S2, L2) :-
	( ( L1 == local,
	    L2 == local ) ->
	      fail
	; ( P1 == gnd,
	    P2 == gnd ) ->
	      fail
	; true
	).
